import express from 'express';
import axios from 'axios';
import * as cheerio from 'cheerio';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { PATHS } from '../config.js';
const router = express.Router();
const execPromise = promisify(exec);

// Função para calcular o token de sindicação (baseado no yt-dlp)
const generateSyndicationToken = (twid) => {
  return ((parseInt(twid) / 1e15) * Math.PI).toString(36).replace(/[0.]/g, '');
};

// Função para converter caminho relativo em absoluto
const toAbsoluteUrl = (relativeUrl) => {
  if (relativeUrl && relativeUrl.startsWith('http')) return relativeUrl;
  return new URL(relativeUrl, 'https://twitter.com/').href;
};

// Função para extrair áudio de um vídeo usando ffmpeg
async function extractAudio(videoUrl, outputFile) {
  try {
    const command = `ffmpeg -i "${videoUrl}" -vn -acodec mp3 -y "${outputFile}"`;
    await execPromise(command);
    console.log(`Áudio extraído e salvo em: ${outputFile}`);
    return outputFile;
  } catch (error) {
    console.error('Erro ao extrair áudio com ffmpeg:', error.message);
    throw error;
  }
}

// Função para baixar vídeo M3U8 usando ffmpeg
async function downloadM3U8Video(videoUrl, outputFile) {
  try {
    const command = `ffmpeg -i "${videoUrl}" -c copy -bsf:a aac_adtstoasc "${outputFile}"`;
    await execPromise(command);
    console.log(`Vídeo M3U8 baixado e salvo em: ${outputFile}`);
    return outputFile;
  } catch (error) {
    console.error('Erro ao baixar vídeo M3U8 com ffmpeg:', error.message);
    throw error;
  }
}

// Função para obter metadados do tweet (com fallback para scraping)
async function fetchTwitterPost(url) {
  const twidMatch = url.match(/status\/(\d+)/);
  if (!twidMatch) throw new Error('URL de tweet inválida');

  const twid = twidMatch[1];
  const syndicationUrl = 'https://cdn.syndication.twimg.com/tweet-result';
  const token = generateSyndicationToken(twid);

  try {
    // Tenta o endpoint de sindicação primeiro
    const syndicationResponse = await axios.get(syndicationUrl, {
      headers: {
        'User-Agent': 'Googlebot',
        'Accept': 'application/json',
        'Accept-Language': 'en-US,en;q=0.9,pt-BR;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
      },
      params: {
        id: twid,
        token: token,
      },
      timeout: 30000,
    });

    const tweetData = syndicationResponse.data;
    if (tweetData?.mediaDetails?.length) {
      return tweetData;
    }
  } catch (syndicationError) {
    console.warn('Falha no endpoint de sindicação:', syndicationError.message);
  }

  // Fallback: Scraping da página do tweet
  const htmlResponse = await axios.get(url, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
      'Accept-Language': 'en-US,en;q=0.9,pt-BR;q=0.8',
    },
    timeout: 30000,
  });

  const $ = cheerio.load(htmlResponse.data);
  const scriptData = $('script[type="application/json"]').html();
  if (scriptData) {
    const jsonData = JSON.parse(scriptData);
    const mediaDetails = jsonData?.entry?.content?.itemContent?.media?.mediaDetails || [];
    if (mediaDetails.length) {
      return { mediaDetails };
    }
  }

  throw new Error('Nenhum vídeo encontrado no tweet');
}

// Endpoint para download de vídeo
router.get('/video', async (req, res, next) => {
  const { url } = req.query;
  if (!url) return res.status(400).send('Passe ?url= do Twitter');

  try {
    const tweetData = await fetchTwitterPost(url);
    const media = tweetData.mediaDetails[0]; // Pega a primeira mídia
    const videoInfo = media.video_info || {};
    const variants = videoInfo.variants || [];

    // Prioriza MP4, mas aceita M3U8 como fallback
    const videoVariant = variants.find(v => v.content_type === 'video/mp4') ||
                        variants.find(v => v.content_type === 'application/x-mpegURL');

    if (!videoVariant) {
      return res.status(404).send('Nenhuma variante de vídeo encontrada');
    }

    const videoUrl = toAbsoluteUrl(videoVariant.url);
    const isM3U8 = videoVariant.content_type === 'application/x-mpegURL';
    const startTime = Date.now();

    if (isM3U8) {
      // Baixa M3U8 com ffmpeg e envia o arquivo
      const tempFile = path.join(PATHS.tempDir,, `temp_video_${media.id_str || Date.now()}.mp4`);
      await downloadM3U8Video(videoUrl, tempFile);

      res.setHeader('Content-Disposition', `attachment; filename=video_${media.id_str || Date.now()}.mp4`);
      res.setHeader('Content-Type', 'video/mp4');

      const stream = (await fs.open(tempFile, 'r')).createReadStream();
      stream.pipe(res);
      stream.on('end', async () => {
        console.log(`Vídeo enviado em ${(Date.now() - startTime)/1000}s`);
        await fs.unlink(tempFile).catch(err => console.error('Erro ao deletar arquivo temporário:', err.message));
      });
      stream.on('error', (err) => {
        console.error('Erro no stream do vídeo:', err.message);
        res.status(500).send('Erro ao enviar vídeo');
      });
    } else {
      // Baixa MP4 diretamente
      const stream = await axios({ url: videoUrl, method: 'GET', responseType: 'stream' });
      res.setHeader('Content-Disposition', `attachment; filename=video_${media.id_str || Date.now()}.mp4`);
      res.setHeader('Content-Type', 'video/mp4');

      stream.data.pipe(res);
      stream.data.on('end', () => {
        console.log(`Vídeo enviado em ${(Date.now() - startTime)/1000}s`);
      });
      stream.data.on('error', (err) => {
        console.error('Erro no stream do vídeo:', err.message);
        res.status(500).send('Erro ao enviar vídeo');
      });
    }
  } catch (err) {
    next(err);
  }
});

// Endpoint para download de áudio
router.get('/audio', async (req, res, next) => {
  const { url } = req.query;
  if (!url) return res.status(400).send('Passe ?url= do Twitter');

  try {
    const tweetData = await fetchTwitterPost(url);
    const media = tweetData.mediaDetails[0]; // Pega a primeira mídia
    const videoInfo = media.video_info || {};
    const variants = videoInfo.variants || [];

    // Prioriza MP4, mas aceita M3U8 como fallback
    const videoVariant = variants.find(v => v.content_type === 'video/mp4') ||
                        variants.find(v => v.content_type === 'application/x-mpegURL');

    if (!videoVariant) {
      return res.status(404).send('Nenhuma variante de vídeo encontrada');
    }

    const videoUrl = toAbsoluteUrl(videoVariant.url);
    const isM3U8 = videoVariant.content_type === 'application/x-mpegURL';
    const startTime = Date.now();

    // Extrai áudio com ffmpeg
    const tempAudioFile = path.join(PATHS.tempDir, `temp_audio_${media.id_str || Date.now()}.mp3`);
    await extractAudio(videoUrl, tempAudioFile);

    res.setHeader('Content-Disposition', `attachment; filename=audio_${media.id_str || Date.now()}.mp3`);
    res.setHeader('Content-Type', 'audio/mpeg');

    const stream = (await fs.open(tempAudioFile, 'r')).createReadStream();
    stream.pipe(res);
    stream.on('end', async () => {
      console.log(`Áudio enviado em ${(Date.now() - startTime)/1000}s`);
      await fs.unlink(tempAudioFile).catch(err => console.error('Erro ao deletar arquivo temporário:', err.message));
    });
    stream.on('error', (err) => {
      console.error('Erro no stream do áudio:', err.message);
      res.status(500).send('Erro ao enviar áudio');
    });
  } catch (err) {
    next(err);
  }
});

export default router;